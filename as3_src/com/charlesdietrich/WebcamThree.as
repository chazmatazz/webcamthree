/*webcamthreehttps://github.com/chazmatazz/webcamthreeJavaScript library for webcam output. Interfaces with Flash AS3. Includes black and white output, useful for tracking fiducials.Copyright (c) 2011 Charles Dietrich http://www.charlesdietrich.comLicensed under the GNU Lesser Public Licensehttp://www.gnu.org/licenses/lgpl.htmlPRIOR WORKJPEGCamhttp://code.google.com/p/jpegcam/Webcam library for capturing JPEG images and submitting to a serverCopyright (c) 2008 - 2009 Joseph Huckaby <jhuckaby@goldcartridge.com>Licensed under the GNU Lesser Public Licensehttp://www.gnu.org/licenses/lgpl.htmlCamCanvas-API-https://github.com/taboca/CamCanvas-API-Copyright (c) 2009 Marcio S Galli, http://www.taboca.com/Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the"Software"), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BELIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTIONOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTIONWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/package com.charlesdietrich{	import flash.display.LoaderInfo;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.*;	import flash.utils.*;	import flash.media.Camera;	import flash.media.Video;	import flash.external.ExternalInterface;	import flash.net.*;	import flash.system.Security;	import flash.system.SecurityPanel;	import flash.geom.Matrix;	import flash.utils.ByteArray;	import flash.geom.Rectangle;	import flash.filters.ColorMatrixFilter;	import flash.geom.Point;	import ru.inspirit.IntegralImageThresholding;	public class WebcamThree extends Sprite {		private var video:Video;		private var camera:Camera;		private var thresholder:IntegralImageThresholding;		private var bmp:Bitmap;		private var camdata:BitmapData;		private var outdata:BitmapData;		private var outdata2:BitmapData;		private var zeroPoint:Point;		private var bytes:ByteArray;		private var matrix:ColorMatrixFilter;		private var i:int;		private var j:int;		private var k:int;		// http://board.flashkit.com/board/showthread.php?t=719855		private var MAX_RETURN:int=36000;		private var num_bw_lines:int;		private var num_bw_divisions:int;		private var bw_data:Array;		private var RGB_NUM_DIGITS:int=11;		private var num_rgb_lines:int;		private var num_rgb_divisions:int;		private var rgb_data:Array;		public function WebcamThree() {			// class constructor			flash.system.Security.allowDomain("*");			stage.scaleMode=StageScaleMode.NO_SCALE;			stage.align=StageAlign.TOP_LEFT;			stage.stageWidth=width;			stage.stageHeight=height;			// From: http://www.squidder.com/2009/03/09/trick-auto-select-mac-isight-in-flash/			var cameraIdx:int=-1;			var idx:int;			var len:int;			for (idx=0,len=Camera.names.length; idx < len; idx++) {				if (Camera.names[idx] == "USB Video Class Video") {					cameraIdx=idx;					idx=len;				}			}			if (cameraIdx > -1) {				camera=Camera.getCamera(String(cameraIdx));			} else {				camera=Camera.getCamera();			}			if (camera != null) {				video=new Video(width,height);				video.attachCamera(camera);				addChild(video);				camera.setQuality(0,100);				camera.setKeyFrameInterval(10);				camera.setMode(width,height,30);				// do not detect motion (may help reduce CPU usage)				camera.setMotionLevel(100);				const rc:Number=.30,gc:Number=.59,bc:Number=.11;				matrix=new ColorMatrixFilter([rc,gc,bc,0,0,rc,gc,bc,0,0,rc,gc,bc,0,0,0,0,0,1,0]);				zeroPoint=new Point();				outdata=new BitmapData(width,height);				camdata=new BitmapData(width,height);				outdata2 = new BitmapData(width, height);				num_bw_lines=Math.floor(height / Math.ceil(height / Math.floor(MAX_RETURN / width)));				num_bw_divisions=height / num_bw_lines;				bw_data=new Array(width * num_bw_lines);				num_rgb_lines=Math.floor(height / Math.ceil(height / Math.floor(MAX_RETURN / RGB_NUM_DIGITS / width)));				num_rgb_divisions=height / num_rgb_lines;				rgb_data=new Array(width * num_rgb_lines);								thresholder = new IntegralImageThresholding(width, height);								if (ExternalInterface.available) {					try {						ExternalInterface.addCallback("doRGBCapture",doRGBCapture);						ExternalInterface.addCallback("doBWCapture",doBWCapture);					} catch (error:SecurityError) {						ExternalInterface.call('webcamThree.flash_notify',"error","A SecurityError occurred: " + error.message + "\n");					} catch (error:Error) {						ExternalInterface.call('webcamThree.flash_notify',"error","An Error occurred: " + error.message + "\n");					}				} else {					ExternalInterface.call('webcamThree.flash_notify',"error","External interface is not available for this container.");				}			} else {				ExternalInterface.call('webcamThree.flash_notify',"error","No camera was detected.");			}		}		public function doBWCapture():void {			camdata.draw(video);			outdata.applyFilter(camdata,camdata.rect,zeroPoint,matrix);			thresholder.doThreshold(outdata, outdata2);						for (k=0; k < num_bw_divisions; k++) {				for (i=0; i < num_bw_lines; i++) {					for (j=0; j < width; j++) {						if(outdata2.getPixel(j,i + k * num_bw_lines) == 0) {							bw_data[i * width + j] = "0";						} else {							bw_data[i * width + j] = "1";						}					}				}				ExternalInterface.call("webcamThree.passBWData",bw_data.join(""));			}		}		public function doRGBCapture():void {			camdata.draw(video);			for (k=0; k < num_rgb_divisions; k++) {				for (i=0; i < num_rgb_lines; i++) {					for (j=0; j < width; j++) {						rgb_data[i * width + j]=String(camdata.getPixel(j,i + k * num_rgb_lines));					}				}				ExternalInterface.call("webcamThree.passRGBData",rgb_data.join("-"));			}		}	}}