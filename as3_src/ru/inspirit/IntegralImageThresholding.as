/*webcamthreehttps://github.com/chazmatazz/webcamthreeJavaScript library for webcam output. Interfaces with Flash AS3. Includes black and white output, useful for tracking fiducials.Copyright (c) 2011 Charles Dietrich http://www.charlesdietrich.comLicensed under the GNU Lesser Public Licensehttp://www.gnu.org/licenses/lgpl.htmlAdapted from http://blog.inspirit.ru/?p=322*/package ru.inspirit{	import flash.display.BitmapData;	public class IntegralImageThresholding {		private var T:Number=0.15;		private var IT:Number=1.0 - T;		private var w:int;		private var h:int;		private var size:int;		private var S:int;		private var S2:int;				public function IntegralImageThresholding(width:int, height:int) {			h=height;			w=width;			size=w * h;			S=w / 8;			S2=S >> 1;		}		/**		    * @param bmp Input image (should be gray scaled)		    * @param dst Result image		    */		public function doThreshold(bmp:BitmapData,dst:BitmapData):void {			var data:Vector.<uint> = bmp.getVector(bmp.rect);			var integral:Vector.<int> = new Vector.<int>(size, true);			var threshold:Vector.<uint> = new Vector.<uint>(size, true);			var i:int, j:int, diff:int;			var x1:int, y1:int, x2:int, y2:int, ind1:int, ind2:int, ind3:int;			var sum:int = 0;			var ind:int = 0;		 			while( ind < size )			{				sum += data[ind] & 0xFF;				integral[ind] = sum;				ind += w;			}		 			x1 = 0;			for( i = 1; i < w; ++i )			{				sum = 0;				ind = i;				ind3 = ind - S2;		 				if( i > S ) x1 = i - S;				diff = i - x1;				for( j = 0; j < h; ++j )				{					sum += data[ind] & 0xFF;					integral[ind] = integral[int(ind-1)] + sum;					ind += w;		 					if(i < S2) continue;					if(j < S2) continue;		 					y1 = (j < S ? 0 : j - S);		 					ind1 = y1 * w;					ind2 = j * w;		 					if (((data[ind3]&0xFF)*(diff * (j - y1))) < ((integral[int(ind2 + i)] - integral[int(ind1 + i)] - integral[int(ind2 + x1)] + integral[int(ind1 + x1)])*IT))					{						threshold[ind3] = 0x0;					} else {						threshold[ind3] = 0xFFFFFFFF;					}					ind3 += w;				}			}		 			y1 = 0;			for( j = 0; j < h; ++j )			{				i = 0;				y2 = h - 1;				if( j < h - S2 ) 				{					i = w - S2;					y2 = j + S2;				}		 				ind = j * w + i;				if( j > S2 ) y1 = j - S2;				ind1 = y1 * w;				ind2 = y2 * w;				diff = y2 - y1;				for( ; i < w; ++i, ++ind )				{		 					x1 = ( i < S2 ? 0 : i - S2);					x2 = i + S2;		 					// check the border					if (x2 >= w) x2 = w - 1;		 					if (((data[ind]&0xFF)*((x2 - x1) * diff)) < ((integral[int(ind2 + x2)] - integral[int(ind1 + x2)] - integral[int(ind2 + x1)] + integral[int(ind1 + x1)])*IT))					{						threshold[ind] = 0x0;					} else {						threshold[ind] = 0xFFFFFFFF;					}				}			}		 			dst.setVector(dst.rect, threshold);		}	}}